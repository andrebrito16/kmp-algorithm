<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <title>Algoritmo de Knuth-Morris-Pratt (KMP)</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700;1,400;1,700&family=Open+Sans+Condensed:ital,wght@0,300;1,300&family=Open+Sans:ital,wght@0,300;0,400;0,700;0,800;1,300;1,400;1,700;1,800&family=Oxygen+Mono&family=Josefin+Sans:ital,wght@0,200;0,600;1,200;1,600&display=swap">
        <link rel="stylesheet" href="assets/css/reset.css">
        <link rel="stylesheet" href="assets/css/highlight.css">
        <link rel="stylesheet" href="assets/css/style.css">
        <link rel="stylesheet" href="assets/css/color.css">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script async src="https://static.codepen.io/assets/embed/ei.js"></script>
        <script src="assets/js/highlight.js"></script>
        <script src="assets/js/script.js"></script>
    </head>
    <body>
        <div class="container">
            <header>
                <a href="">abrir tudo</a>
                <a href="">fechar tudo</a>
            </header>
            <main>

<p><a href="https://ensino.hashi.pro.br/desprog/" target="_blank">Desafios de Programação</a></p>
<h1>Algoritmo de Knuth-Morris-Pratt (KMP)</h1>
<div class="slide">
<div class="slide-container">
<div class="slide-header">

</div>
<div class="slide-main">
<p>Desafios de Programação</p>
<p><strong>Aula 22: Knuth-Morris-Pratt (KMP)</strong></p>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
História KMP
</div>
<div class="slide-main">
<ul>
<li class="frame small">
<p>É uma das soluções mais eficientes para o problema de correspondência de padrões em uma string.</p>
</li>
<li class="frame small">
<p>Desenvolvido em 1977 pelos pesquisadores Donald Knuth, James Morris e Vaughan Pratt</p>
</li>
<li class="frame small">
<p>Utilizado em áreas como Processamento de Linguagem Neural, Ánalise de Dados e Bioinformática</p>
</li>
</ul>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
Essência do KMP
</div>
<div class="slide-main">
<ul>
<li class="frame small">O algoritmo KMP inicia comparando caractere por caractere do padrão com o texto.</li>
<li class="frame small">Se ocorre um mismatch, o KMP usa a lógica de sufixos de prefixos para otimizar a busca, não necessariamente recomeçando as comparações do zero.</li>
<li class="frame small">Uma tabela de falha, utilizada para determinar saltos, é construída como consequência da lógica de sufixos de prefixos, facilitando a busca de padrões.</li>
</ul>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento00.png" alt=""></figure>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento01.png" alt=""></figure>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento02.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento03.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento04.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento05.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento06.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento07.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento08.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento09.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento10.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento11.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento12.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento13.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento14.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento15.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento16.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento17.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento18.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento19.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento20.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento21.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
=
</div>
<div class="slide-main">
<figure class="img"><img src="img/Funcionamento/Funcionamento22.png" alt=""></figure>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">
Vantagens do Algoritmo
</div>
<div class="slide-main">
<ul>
<li class="frame">
<p>Eficiência: Evita comparações desnecessárias, resultando em um processo de busca mais rápido.</p>
</li>
<li class="frame">
<p>Utilização da tabela: A tabela auxilia no cálculo dos saltos, otimizando a localização dos padrões.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">

</div>
<div class="slide-main">
<p><strong>Handout</strong></p>
<ul>
<li class="small">
<p>Agora podem tanto fazer individualmente quanto em grupo…</p>
</li>
<li class="small">
<p>…e discussões em grupo podem de fato fazer diferença…</p>
</li>
<li class="small">
<p>…mas, em algum momento, é importante fazer individualmente.</p>
</li>
<li class="small">
<p>Se há gabarito, veja só em último caso.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="slide">
<div class="slide-container">
<div class="slide-header">

</div>
<div class="slide-main">
<p><strong>Observações</strong></p>
<ul>
<li class="small">
<p>Aprendizado ativo é fazer, não ler.</p>
</li>
<li class="small">
<p>Exceto em um ou outro caso excepcional, uma atividade é possível sem consulta além do material de aula dado até o momento.</p>
</li>
<li class="small">
<p>Além disso, muitas vezes a resposta da atividade é necessária para a compreensão do restante.</p>
</li>
<li class="small">
<p>Ou seja, “deixar para entender depois” não faz sentido. “Depois” depende de “entender”.</p>
</li>
</ul>
</div>
</div>
</div>
<h2>1.O Problema da Busca de Substrings</h2>
<p>A busca de substrings é um problema comum em ciência da computação. A questão é: dado um texto e um padrão, podemos encontrar todas as ocorrências do padrão dentro do texto?</p>
<p>A solução mais simples, mas também a mais lenta, é verificar cada substring do texto em sequência para ver se ela corresponde ao padrão, a chamada força bruta. No entanto, essa abordagem é muito ineficiente, especialmente para textos longos, já que o número de comparações feitas será muito grande.</p>
<p>Então como podemos melhorar a eficiência em comparações de strings?</p>
<p>Felizmente, existem algoritmos mais rápidos. O Algoritmo de Knuth-Morris-Pratt (KMP) é um desses algoritmos. Em vez de se mover um caractere por vez, como na busca de padrões convencional, ele permite que você <strong>“pule”</strong> partes do texto com base no conhecimento adquirido até o momento.</p>
<h2>2.Compreendendo os Prefixos e Sufixos de Prefixos</h2>
<p>No contexto do algoritmo KMP, prefixos são partes iniciais do padrão. Para o padrão <strong>“ABCDE”</strong>, os prefixos são <strong>“A”</strong>, <strong>“AB”</strong>, <strong>“ABC”</strong>, <strong>“ABCD”</strong>, excluindo-se a própria string original.</p>
<blockquote class="question">
<p>Checkpoint 1</p>
<p><strong>a)</strong> Quais são os prefixos da palavra <strong>“DESPROG”</strong>?</p>
<p><strong>b)</strong> Quantos prefixos existem? Descreva o processo de como você chegou a essa resposta.</p>
<details class="answer">
<summary>Gabarito</summary>
<p><strong>a)</strong> Os prefixos da palavra <strong>“DESPROG”</strong> são <strong>“D”</strong>, <strong>“DE”</strong>, <strong>“DES”</strong>, <strong>“DESP”</strong>, <strong>“DESPR”</strong>, <strong>“DESPRO”</strong>.</p>
<p><strong>b)</strong> Existem 6 prefixos. Para encontrar esses prefixos, começamos do primeiro caractere e vamos adicionando um caractere de cada vez até chegar ao penúltimo.</p>
</details>
</blockquote>
<p>Um sufixo de prefixo é qualquer sufixo que pode ser extraído de um prefixo do padrão. No caso do prefixo <strong>“ABC”</strong>, temos dois sufixos: <strong>“BC”</strong> e <strong>“C”</strong>.</p>
<blockquote class="question">
<p>Checkpoint 2</p>
<p>Quais são os sufixos possíveis para cada prefixo da palavra <strong>“DESPROG”</strong> que você encontrou no checkpoint 1?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>Os sufixos de cada prefixo são os seguintes:<br>
<strong>“D”</strong>: nenhum sufixo<br>
<strong>“DE”</strong>: <strong>“E”</strong><br>
<strong>“DES”</strong>: <strong>“ES”</strong>, <strong>“S”</strong><br>
<strong>“DESP”</strong>: <strong>“ESP”</strong>, <strong>“SP”</strong>, <strong>“P”</strong><br>
<strong>“DESPR”</strong>: <strong>“ESPR”</strong>, <strong>“SPR”</strong>, <strong>“PR”</strong>, <strong>“R”</strong><br>
<strong>“DESPRO”</strong>: <strong>“ESPRO”</strong>, <strong>“SPRO”</strong>, <strong>“PRO”</strong>, <strong>“RO”</strong>, <strong>“O”</strong></p>
</details>
</blockquote>
<p><strong>Mas por que precisamos saber sobre prefixos e sufixos?</strong></p>
<p>Vamos dizer que estamos procurando o padrão <strong>“ABCABC”</strong> dentro de um texto e encontramos um match parcial - <strong>“ABCAB”</strong>, mas o próximo caractere no texto é <strong>“D”</strong>, não <strong>“C”</strong>. Isso significa que temos um mismatch. Em um algoritmo de busca normal, começaríamos a busca novamente a partir do próximo caractere.</p>
<p>No entanto, o algoritmo KMP faz algo mais inteligente. Ele observa o match parcial (“ABCAB”) e verifica se há algum sufixo deste match parcial que corresponda a um prefixo do padrão original. Neste caso, <strong>“AB”</strong> no final de <strong>“ABCAB”</strong> é um sufixo do match parcial e também um prefixo do padrão original <strong>“ABCABC”</strong>. Isso significa que podemos <strong>“saltar”</strong> para o próximo local no texto que alinha este sufixo <strong>“AB”</strong> com o prefixo <strong>“AB”</strong> do padrão original na próxima etapa da busca, pois já sabemos que a parte <strong>“AB”</strong> é uma correspondência válida.</p>
<p>Assim, em vez de mover um caractere de cada vez, <strong>o algoritmo KMP pode mover vários caracteres de uma vez</strong>, tornando a busca muito mais eficiente. Essa é a ideia central do algoritmo KMP.</p>
<figure class="img"><img src="img/pikachu.jpg" alt=""></figure>
<h2>3.Funcionamento do KMP</h2>
<p>Vamos dar um passo a passo de como o algoritmo KMP executa um “salto” durante a busca de um padrão em um texto. Para isso, vamos considerar o padrão “ACAC" e supor que estamos procurando por ele em um texto.</p>
<div class="animation"><img class="frame" src="img/Pulo_sem_tabela/pulo00.png" alt="1"><img class="frame" src="img/Pulo_sem_tabela/pulo01.png" alt="2"><img class="frame" src="img/Pulo_sem_tabela/pulo02.png" alt="3"><img class="frame" src="img/Pulo_sem_tabela/pulo03.png" alt="4"><img class="frame" src="img/Pulo_sem_tabela/pulo04.png" alt="5"><img class="frame" src="img/Pulo_sem_tabela/pulo05.png" alt="6"></div>
<ul>
<li>
<p>Passo 1: Iniciamos a busca do padrão (“ACAC”) no texto, começando do primeiro caractere de ambos.</p>
</li>
<li>
<p>Passo 2: Comparamos os caracteres um a um. Suponha que encontramos um match parcial “ACA”, mas o próximo caractere do texto não é o esperado, então temos um desajuste.</p>
</li>
<li>
<p>Passo 3: Agora, em vez de começar a busca do zero, olhamos para o match parcial “ACA”. Procuramos o maior sufixo deste match que também é um prefixo do padrão. Neste caso, é “A”. Este sufixo tem um comprimento de 1.</p>
</li>
<li>
<p>Passo 4: O tamanho do padrão é 3. Então, subtraímos o tamanho do sufixo do prefixo (1) do tamanho do padrão (3), o que nos dá um “salto” de 2 posições.</p>
</li>
<li>
<p>Passo 5: Movemos a busca para a frente no texto de maneira que este sufixo “A” do texto se alinhe com o prefixo “ACA” do padrão. Isso significa que pulamos a busca para duas posições à frente.</p>
</li>
<li>
<p>Passo 6: Continuamos a busca a partir desta posição, ou seja, continuamos a partir do caractere seguinte ao “A” no texto e no padrão.</p>
</li>
</ul>
<p>Este processo de “salto” otimiza a busca, pois evita começar do início toda vez que encontramos um desajuste. Em vez disso, usamos a informação que já temos (o match parcial) para pular para uma posição que ainda tem chance de resultar em um match completo. Isso torna a busca muito mais eficiente.</p>
<h2>4.A tabela LPS</h2>
<p>A tabela LPS é uma representação pré-computada (cache) que armazena informações sobre cada prefixo do padrão e o tamanho do maior sufixo desse prefixo que também é um prefixo. Esse tamanho é usado como um índice que indica quantos caracteres a palavra ou frase deve avançar.</p>
<div class="animation"><img class="frame" src="img/tabela_prefixo/prefixo0.png" alt="1"><img class="frame" src="img/tabela_prefixo/prefixo1.png" alt="2"><img class="frame" src="img/tabela_prefixo/prefixo2.png" alt="3"><img class="frame" src="img/tabela_prefixo/prefixo3.png" alt="4"><img class="frame" src="img/tabela_prefixo/prefixo4.png" alt="5"><img class="frame" src="img/tabela_prefixo/prefixo5.png" alt="6"><img class="frame" src="img/tabela_prefixo/prefixo6.png" alt="7"><img class="frame" src="img/tabela_prefixo/prefixo7.png" alt="8"><img class="frame" src="img/tabela_prefixo/prefixo8.png" alt="9"></div>
<p>Agora que aprendemos, vamos fazer alguns exercícios para fixar o conteúdo.</p>
<blockquote class="question">
<p>Exercício 1</p>
<p>Construa a tabela de prefixos e sufixos para:</p>
<figure class="img"><img src="img/Exercicios/Exercicio1.png" alt=""></figure>
<details class="answer">
<summary>Gabarito</summary>
<figure class="img"><img src="img/Gabaritos/Gabarito1.png" alt=""></figure>
</details>
<details class="answer">
<summary>Gabarito Detalhado</summary>
<div class="animation"><img class="frame" src="img/Gabarito_Detalhado_1/GabaritoDetalhado10.png" alt="1"><img class="frame" src="img/Gabarito_Detalhado_1/GabaritoDetalhado11.png" alt="2"><img class="frame" src="img/Gabarito_Detalhado_1/GabaritoDetalhado12.png" alt="3"><img class="frame" src="img/Gabarito_Detalhado_1/GabaritoDetalhado13.png" alt="4"><img class="frame" src="img/Gabarito_Detalhado_1/GabaritoDetalhado14.png" alt="5"><img class="frame" src="img/Gabarito_Detalhado_1/GabaritoDetalhado15.png" alt="6"></div>
</details>
</blockquote>
<blockquote class="question">
<p>Exercício 2</p>
<p>Construa a tabela de prefixos e sufixos para:</p>
<figure class="img"><img src="img/Exercicios/Exercicio2.png" alt=""></figure>
<details class="answer">
<summary>Gabarito</summary>
<figure class="img"><img src="img/Gabaritos/Gabarito2.png" alt=""></figure>
</details>
<details class="answer">
<summary>Gabarito Detalhado</summary>
<div class="animation"><img class="frame" src="img/Gabarito_Detalhado_2/GabaritoDetalhado20.png" alt="1"><img class="frame" src="img/Gabarito_Detalhado_2/GabaritoDetalhado21.png" alt="2"><img class="frame" src="img/Gabarito_Detalhado_2/GabaritoDetalhado22.png" alt="3"><img class="frame" src="img/Gabarito_Detalhado_2/GabaritoDetalhado23.png" alt="4"><img class="frame" src="img/Gabarito_Detalhado_2/GabaritoDetalhado24.png" alt="5"><img class="frame" src="img/Gabarito_Detalhado_2/GabaritoDetalhado25.png" alt="6"><img class="frame" src="img/Gabarito_Detalhado_2/GabaritoDetalhado26.png" alt="7"><img class="frame" src="img/Gabarito_Detalhado_2/GabaritoDetalhado27.png" alt="8"></div>
</details>
</blockquote>
<blockquote class="question">
<p>Exercício 3</p>
<p>Construa a tabela de prefixos e sufixos para:</p>
<figure class="img"><img src="img/Exercicios/Exercicio3.png" alt=""></figure>
<details class="answer">
<summary>Gabarito</summary>
<figure class="img"><img src="img/Gabaritos/Gabarito3.png" alt=""></figure>
</details>
<details class="answer">
<summary>Gabarito Detalhado</summary>
<div class="animation"><img class="frame" src="img/Gabarito_Detalhado_3/GabaritoDetalhado30.png" alt="1"><img class="frame" src="img/Gabarito_Detalhado_3/GabaritoDetalhado31.png" alt="2"><img class="frame" src="img/Gabarito_Detalhado_3/GabaritoDetalhado32.png" alt="3"><img class="frame" src="img/Gabarito_Detalhado_3/GabaritoDetalhado33.png" alt="4"><img class="frame" src="img/Gabarito_Detalhado_3/GabaritoDetalhado34.png" alt="5"><img class="frame" src="img/Gabarito_Detalhado_3/GabaritoDetalhado35.png" alt="6"><img class="frame" src="img/Gabarito_Detalhado_3/GabaritoDetalhado36.png" alt="7"><img class="frame" src="img/Gabarito_Detalhado_3/GabaritoDetalhado37.png" alt="8"><img class="frame" src="img/Gabarito_Detalhado_3/GabaritoDetalhado38.png" alt="9"></div>
</details>
</blockquote>
<h2>5.Pulo com a tabela</h2>
<p>Com a compreensão adequada da mecânica do algoritmo e a construção da tabela LPS, é possível apreender integralmente o funcionamento do algoritmo Knuth-Morris-Pratt.</p>
<div class="animation"><img class="frame" src="img/Funcionamento/Funcionamento00.png" alt="1"><img class="frame" src="img/Funcionamento/Funcionamento01.png" alt="2"><img class="frame" src="img/Funcionamento/Funcionamento02.png" alt="3"><img class="frame" src="img/Funcionamento/Funcionamento03.png" alt="4"><img class="frame" src="img/Funcionamento/Funcionamento04.png" alt="5"><img class="frame" src="img/Funcionamento/Funcionamento05.png" alt="6"><img class="frame" src="img/Funcionamento/Funcionamento06.png" alt="7"><img class="frame" src="img/Funcionamento/Funcionamento07.png" alt="8"><img class="frame" src="img/Funcionamento/Funcionamento08.png" alt="9"><img class="frame" src="img/Funcionamento/Funcionamento09.png" alt="10"><img class="frame" src="img/Funcionamento/Funcionamento10.png" alt="11"><img class="frame" src="img/Funcionamento/Funcionamento11.png" alt="12"><img class="frame" src="img/Funcionamento/Funcionamento12.png" alt="13"><img class="frame" src="img/Funcionamento/Funcionamento13.png" alt="14"><img class="frame" src="img/Funcionamento/Funcionamento14.png" alt="15"><img class="frame" src="img/Funcionamento/Funcionamento15.png" alt="16"><img class="frame" src="img/Funcionamento/Funcionamento16.png" alt="17"><img class="frame" src="img/Funcionamento/Funcionamento17.png" alt="18"><img class="frame" src="img/Funcionamento/Funcionamento18.png" alt="19"><img class="frame" src="img/Funcionamento/Funcionamento19.png" alt="20"><img class="frame" src="img/Funcionamento/Funcionamento20.png" alt="21"><img class="frame" src="img/Funcionamento/Funcionamento21.png" alt="22"><img class="frame" src="img/Funcionamento/Funcionamento22.png" alt="23"></div>
<h2>6.Implementação em C</h2>
<p>Como explicado nesse handout, o KMP utiliza a <strong>tabela LPS</strong> como um cache. Ou seja, antes de aplicar o algoritmo de fato, devemos gerar essa tabela.</p>
<h2>Implementação da função que monta a tabela</h2>
<p>Nesse passo iremos implementar uma função que irá receber o padrão a ser encontrado, o tamanho do padrão e o vetor que será a tabela LPS.</p>
<p>A ideia para montar essa tabela já foi explicada por passos no handout, porém para facilitar a implementação em C, primeiro vamos mostrar
um pseudocódigo.</p>
<h2>Pseudocódigo</h2>
<p>Lembrando que a assinatura da função é algo parecido com <code class="terminal nohighlight"> gerar_tabela_LPS(char *padrão, int n, int *lps)</code>.</p>
<p>Muito bem, agora vamos ao pseudocódigo de fato.</p>
<pre><code class="language-s">Definir o comprimento como zero
Definir o primeiro elemento do array de prefixo como zero

Definir "i" como 1

Enquanto "i" for menor que o tamanho do padrão:
    Se o i-ésimo caractere do padrão é igual ao caractere no índice de "comprimento" do padrão:
        Incrementar o comprimento
        Definir o i-ésimo elemento do array de prefixo como o comprimento
        Incrementar "i"
    Senão:
        Se o comprimento não é zero:
            Definir o comprimento como o valor no índice "comprimento - 1" do array de prefixo
        Senão:
            Definir o i-ésimo elemento do array de prefixo como zero
            Incrementar "i"
</code></pre>
<blockquote class="warning">
<p>Aviso</p>
<p>Procure entender bem o pseudocódigo dessa função.</p>
</blockquote>
<blockquote class="question">
<p>Pergunta</p>
<p>Agora que você já entendeu bem, como ficaria a implementação da função que calcula a tabela
LPS em C?</p>
<details class="answer">
<summary>Resposta</summary>
<blockquote class="warning">
<p>Aviso</p>
<p>Lembre-se que essa função não retorna nada, só escreve no array que teve seu endereço passado como argumento da função.</p>
</blockquote>
<pre><code class="language-c">void gera_tabela_lps(char *padrão, int n, int *lps) {
    int tamanho = 0;
    lps[0] = 0;

    int i = 1;
    while (i &lt; n) {
        if (padrão[i] == padrão[tamanho]) {
            tamanho++;
            lps[i] = tamanho;
            i++;
        } else {
            if (tamanho != 0) {
                tamanho = lps[tamanho - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
}

</code></pre>
</details>
</blockquote>
<h2>Implementação do KMP</h2>
<p>Bem, agora que já temos a função que calcula a tabela LPS podemos, finalmente, aplicar o algoritmo KMP. mas antes, como de costume,
vamos ao pseudocódigo.</p>
<h2>Pseudocódigo</h2>
<p>A função do KMP deverá receber como argumento apenas o texto e o padrão que queremos buscar nesse texto.</p>
<p>Dado isso, o pseudocódigo fica assim:</p>
<pre><code class="language-s">Função para buscar o padrão no texto (texto, padrão):
    Definir M como o tamanho do padrão
    Definir N como o tamanho do texto

    Criar um array lps de tamanho M
    Chamar a função para calcular o array de prefixo (padrão, M, lps)

    Definir "i" e "j" como zero

    Enquanto "i" for menor que N:
        Se o j-ésimo caractere do padrão é igual ao i-ésimo caractere do texto:
            Incrementar "j"
            Incrementar "i"
            
        Se "j" for igual a M:
            índice é igual a (i - j). E o padrão foi encontrado nesse índice.
            Se "j" não é zero:
                Definir "j" como o valor no índice "j - 1" do array lps

        Senão, se "i" for menor que N e o j-ésimo caractere do padrão não é igual ao i-ésimo caractere do texto:
            Se "j" não é zero:
                Definir "j" como o valor no índice "j - 1" do array lps
            Senão:
                Incrementar "i"
</code></pre>
<blockquote class="question">
<p>Pergunta</p>
<p>Agora que você já viu <s>e entendeu</s> o pseudocódigo, como fica a implementação do KMP em C?</p>
<details class="answer">
<summary>Resposta</summary>
<pre><code class="language-c">void KMP(char *texto, char *padrao) {
    int M = strlen(padrao);
    int N = strlen(text);

    int lps[M];

    gera_tabela_lps(padrao, M, lps);

    int i = 0;
    int j = 0;
    while (i &lt; N) {
        if (padrao[j] == text[i]) {
            j++;
            i++;
        }

        if (j == M) {
            printf("Padrão encontrado no índice: %d\n", i - j);
            j = lps[j - 1];
        } else if (i &lt; N &amp;&amp; padrao[j] != text[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i = i + 1;
            }
        }
    }
}


</code></pre>
<p>Você deve ter percebido que nesse código há o uso da função <code class="language-s">strlen</code> que vem da biblioteca, <code class="language-s">string</code>, por isso não esqueça de incluir
no seu código.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</code></pre>
<p>Lembrando que essa função foi usada apenas para facilitar as coisas, você já fez muitos “whiles” em C durante o semestre, se podemos poupar de dois
por que não fazer, não é?</p>
<blockquote class="warning">
<p>Aviso</p>
<p>Essa função não retorna nada, porém ela poderia ser facilmente modificada para retornar um inteiro com o índice de onde a ocorrência foi encontrada.</p>
</blockquote>
</details>
</blockquote>


            </main>
            <footer>
                <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
                    <img alt="CC BY-SA 4.0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" title="Creative Commons Attribution-ShareAlike 4.0 International License"/>
                </a>
                © 2022 Marcelo Hashimoto
            </footer>
        </div>
    </body>
</html>
