<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <title>Algoritmo de Knuth-Morris-Pratt (KMP)</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700;1,400;1,700&family=Open+Sans+Condensed:ital,wght@0,300;1,300&family=Open+Sans:ital,wght@0,300;0,400;0,700;0,800;1,300;1,400;1,700;1,800&family=Oxygen+Mono&family=Josefin+Sans:ital,wght@0,200;0,600;1,200;1,600&display=swap">
        <link rel="stylesheet" href="assets/css/reset.css">
        <link rel="stylesheet" href="assets/css/highlight.css">
        <link rel="stylesheet" href="assets/css/style.css">
        <link rel="stylesheet" href="assets/css/color.css">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script async src="https://static.codepen.io/assets/embed/ei.js"></script>
        <script src="assets/js/highlight.js"></script>
        <script src="assets/js/script.js"></script>
    </head>
    <body>
        <div class="container">
            <header>
                <a href="">abrir tudo</a>
                <a href="">fechar tudo</a>
            </header>
            <main>

<p><a href="https://ensino.hashi.pro.br/desprog/" target="_blank">Desafios de Programação</a></p>
<h1>Algoritmo de Knuth-Morris-Pratt (KMP)</h1>
<h2>1.Introdução</h2>
<p>O algoritmo de Knuth-Morris-Pratt (KMP) é uma das soluções mais eficientes para o problema de correspondência de padrões em uma string. Esse problema é muito importante em diversas áreas, como processamento de linguagem natural, análise de dados e bioinformática.</p>
<p>Desenvolvido em 1977 pelos pesquisadores Donald Knuth, James Morris e Vaughan Pratt, o algoritmo KMP tem sido amplamente utilizado em diversas aplicações, desde então.</p>
<p>Este handout tem como objetivo apresentar o funcionamento detalhado do algoritmo KMP, como ele pode ser implementado e otimizado, e como ele se compara com outros algoritmos de correspondência de padrões. Além disso, também exploraremos alguns exemplos práticos do uso do algoritmo.</p>
<h2>2.E por que estudar o algoritmo KMP?</h2>
<p>Sabe quando você quer encontrar uma frase ou palavra, e para isso usa o famoso CTRL + F, ele costuma indicar as posições das ocorrências ou mostrar que ela não está presente no texto.</p>
<p>O algoritmo torna esse processo mais rápido, evitando repetições de comparações desnecessárias, a gente vai aprender um pouco mais na frente, mas ele usa uma tabela para auxiliar o processo.
Começando o algoritmo compara o primeiro caractere do padrão (frase ou palavra) com o primeiro caractere do texto, caso os demais caracteres tenham correspondência, ele compara caractere por caractere, até encontrar uma diferença. Encontrada a diferença, o algoritmo vai usar a tabela para saber o quanto deve “pular” para o próximo caractere.</p>
<p>Sendo o KMP um poderoso algoritmo para solucionar o problema de correspondência de padrões de forma rápida e eficiente.</p>
<blockquote class="warning">
<p>Aviso</p>
<p>Essa parte 2 (“E por que estudar o algoritmo KMP?”) poderia ser um expositvo? Ou melhor em texto?</p>
</blockquote>
<h2>4.Implementação em C</h2>
<p>O KMP usa uma tabela de falhas (também conhecida como tabela de borda) para armazenar informações sobre o padrão que são usadas para evitar comparações repetidas. A tabela de falhas é construída antes de iniciar a correspondência de padrões e é baseada no padrão a ser encontrado.</p>
<blockquote class="warning">
<p>Aviso</p>
<p>A ser melhorado</p>
</blockquote>
<blockquote class="question">
<p>Pergunta</p>
<p>Como seria uma implementação do algoritmo KMP em C?</p>
<details class="answer">
<summary>Resposta</summary>
<p>Aqui está um exemplo de implementação do algoritmo KMP em C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void preencher_tabela(int tabela[], char padrao[])
{
    int tam_padrao = strlen(padrao);
    int i = 0, j = -1;
    tabela[0] = -1;

    while (i &lt; tam_padrao)
    {
        while (j &gt;= 0 &amp;&amp; padrao[i] != padrao[j])
        {
            j = tabela[j];
        }

        i++;
        j++;
        tabela[i] = j;
    }
}

void encontrar_padrao(char texto[], char padrao[])
{
    int tam_texto = strlen(texto);
    int tam_padrao = strlen(padrao);
    int tabela[tam_padrao];
    preencher_tabela(tabela, padrao);
    int i = 0, j = 0;

    while (i &lt; tam_texto)
    {
        while (j &gt;= 0 &amp;&amp; texto[i] != padrao[j])
        {
            j = tabela[j];
        }

        i++;
        j++;

        if (j == tam_padrao)
        {
            printf("Padrao encontrado na posicao %d\n", i - j);
            j = tabela[j];
        }
    }
}

int main()
{
    char texto[] = "ababcabcabababcabcabc";
    char padrao[] = "abcabc";
    encontrar_padrao(texto, padrao);
    return 0;
}
</code></pre>
</details>
</blockquote>
<h2>6.Comparação com outros algoritmos</h2>
<p>Existem diversos algoritmos para solucionar o problema de correspondência de padrões, cada um com suas próprias características e complexidades.</p>
<p>O algoritmo de força bruta é a solução mais simples para o problema de correspondência de padrões. Ele consiste em percorrer a string de texto e comparar o padrão com cada uma das substrings. Esse método tem complexidade de tempo O(nm), onde n é o tamanho da string e m é o tamanho do padrão. Apesar de sua simplicidade, esse algoritmo não é eficiente para strings grandes ou padrões longos, já que ele realiza muitas comparações desnecessárias.</p>
<pre><code class="language-c">// pseudocódigo em C do algoritmo de força bruta
int bruteForce(char* texto, char* padrao) {
    int n = strlen(texto); // Tamanho da string de texto
    int m = strlen(padrao); // Tamanho da string de padrão
    int i, j; // Índices para percorrer as strings

    for (i = 0; i &lt;= n - m; i++) { // Percorre a string de texto
        for (j = 0; j &lt; m; j++) { // Percorre a string de padrão
            if (texto[i+j] != padrao[j]) // Se encontrar uma diferença, sai do loop interno
                break;
        }
        if (j == m) // Se o índice j chegou ao final do padrão, significa que encontrou uma ocorrência
            return i;
    }

    return -1; // Se não encontrou ocorrência, retorna -1
}
</code></pre>
<p>O algoritmo de Boyer-Moore, assim como o KMP, utiliza informações sobre a string e o padrão para evitar comparações desnecessárias. Ele é considerado um dos algoritmos mais rápidos para o problema de correspondência de padrões na prática, com uma complexidade de tempo média O(n/m). O algoritmo utiliza duas heurísticas: o salto ruim (bad character rule) e o salto bom (good suffix rule), para determinar o deslocamento necessário na string de texto.</p>
<pre><code class="language-c">// TODO: pseudocódigo em C do algoritmo de Boyer-Moore
</code></pre>
<p>No entanto, é importante lembrar que a eficiência dos algoritmos depende das características específicas da string e do padrão em questão. Por isso, é importante avaliar o desempenho de cada algoritmo para cada caso específico.</p>
<p>Ainda não foram realizados testes para comparar o desempenho do algoritmo KMP com os algoritmos de força bruta e Boyer-Moore. Na próxima sprint, vamos apresentar os resultados desses testes e comparar o desempenho dos algoritmos para diferentes tamanhos de string e padrão.</p>
<h2>TABELA MERAMENTE ILUSTRATIVA</h2>
<figure class="table"><table>
<thead>
<tr>
<th>Tamanho da string</th>
<th>Tamanho do padrão</th>
<th>Força Bruta</th>
<th>KMP</th>
<th>Boyer-Moore</th>
</tr>
</thead>
<tbody>
<tr>
<td>10^4</td>
<td>10</td>
<td>0.003s</td>
<td>0.001s</td>
<td>0.002s</td>
</tr>
<tr>
<td>10^5</td>
<td>100</td>
<td>0.308s</td>
<td>0.011s</td>
<td>0.001s</td>
</tr>
<tr>
<td>10^6</td>
<td>1000</td>
<td>32.5s</td>
<td>0.125s</td>
<td>0.008s</td>
</tr>
</tbody>
</table></figure>


            </main>
            <footer>
                <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
                    <img alt="CC BY-SA 4.0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" title="Creative Commons Attribution-ShareAlike 4.0 International License"/>
                </a>
                © 2022 Marcelo Hashimoto
            </footer>
        </div>
    </body>
</html>
